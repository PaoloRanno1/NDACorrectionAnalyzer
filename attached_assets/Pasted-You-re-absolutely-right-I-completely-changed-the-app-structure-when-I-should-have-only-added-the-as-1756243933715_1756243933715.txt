You're absolutely right! I completely changed the app structure when I should have only added the async tracked changes functionality. Let me give you exactly what I changed for the async implementation so you can rollback and apply just those specific changes.

Here are the specific async changes I made for Direct Tracked Changes Generation:

1. New Async Module (async_direct_changes.py)
import asyncio
import streamlit as st
import tempfile
import os
from typing import Optional, Dict, Any
import threading
import time
import uuid
def run_direct_changes_background(analysis_id: str, file_content: bytes, file_name: str, selected_findings: Dict, user_comments: Dict):
    """Run direct tracked changes generation in background thread"""
    try:
        # Update status
        st.session_state.direct_processing_status = 'processing'
        st.session_state.direct_processing_progress = 10
        st.session_state.direct_processing_message = 'Initializing document processing...'
        
        # Import here to avoid circular imports
        from Tracked_changes_tools_clean import generate_tracked_changes_document
        
        # Create temporary file
        st.session_state.direct_processing_progress = 20
        st.session_state.direct_processing_message = 'Creating temporary files...'
        
        with tempfile.NamedTemporaryFile(mode='w+b', delete=False, suffix='.docx') as temp_file:
            temp_file.write(file_content)
            temp_file_path = temp_file.name
        
        # Process findings
        st.session_state.direct_processing_progress = 40
        st.session_state.direct_processing_message = 'Processing selected findings...'
        
        from Tracked_changes_tools_clean import RawFinding
        
        raw_findings = []
        finding_id = 1
        
        for priority in ['High Priority', 'Medium Priority', 'Low Priority']:
            for idx, finding in selected_findings[priority].items():
                raw_finding = RawFinding(
                    id=finding_id,
                    issue=finding['issue'],
                    citation=finding.get('citation', ''),
                    section=finding.get('section', ''),
                    problem=finding.get('problem', ''),
                    suggested_replacement=finding.get('suggested_replacement', ''),
                    user_comment=user_comments.get(f"{priority}_{idx}", "")
                )
                raw_findings.append(raw_finding)
                finding_id += 1
        
        # Generate documents
        st.session_state.direct_processing_progress = 70
        st.session_state.direct_processing_message = 'Generating tracked changes document...'
        
        tracked_changes_path, clean_edited_path = generate_tracked_changes_document(
            temp_file_path, raw_findings
        )
        
        # Read generated files
        st.session_state.direct_processing_progress = 90
        st.session_state.direct_processing_message = 'Finalizing documents...'
        
        with open(tracked_changes_path, 'rb') as f:
            tracked_changes_content = f.read()
        
        with open(clean_edited_path, 'rb') as f:
            clean_edited_content = f.read()
        
        # Store results
        st.session_state.direct_processing_results = {
            'tracked_changes_content': tracked_changes_content,
            'clean_edited_content': clean_edited_content,
            'original_filename': file_name
        }
        
        # Cleanup
        os.unlink(temp_file_path)
        os.unlink(tracked_changes_path)
        os.unlink(clean_edited_path)
        
        # Complete
        st.session_state.direct_processing_status = 'completed'
        st.session_state.direct_processing_progress = 100
        st.session_state.direct_processing_message = 'Document generation completed!'
        
    except Exception as e:
        st.session_state.direct_processing_status = 'error'
        st.session_state.direct_processing_error = str(e)
        st.session_state.direct_processing_message = f'Error: {str(e)}'
def start_direct_changes_background(file_content: bytes, file_name: str, selected_findings: Dict, user_comments: Dict) -> str:
    """Start background direct changes generation"""
    analysis_id = str(uuid.uuid4())
    
    # Initialize processing state
    st.session_state.direct_processing_status = 'processing'
    st.session_state.direct_processing_progress = 0
    st.session_state.direct_processing_message = 'Starting document generation...'
    st.session_state.direct_processing_results = None
    st.session_state.direct_processing_error = None
    st.session_state.direct_processing_id = analysis_id
    
    # Start background thread
    thread = threading.Thread(
        target=run_direct_changes_background,
        args=(analysis_id, file_content, file_name, selected_findings, user_comments)
    )
    thread.daemon = True
    thread.start()
    
    return analysis_id
2. Session State Initialization (add to initialize_session_state())
# Direct tracked changes processing states
if 'direct_processing_status' not in st.session_state:
    st.session_state.direct_processing_status = 'idle'
if 'direct_processing_progress' not in st.session_state:
    st.session_state.direct_processing_progress = 0
if 'direct_processing_message' not in st.session_state:
    st.session_state.direct_processing_message = ''
if 'direct_processing_results' not in st.session_state:
    st.session_state.direct_processing_results = None
if 'direct_processing_error' not in st.session_state:
    st.session_state.direct_processing_error = None
if 'direct_processing_id' not in st.session_state:
    st.session_state.direct_processing_id = None
3. Replace Direct Changes Section (in the post-review editing section)
Replace the synchronous document generation with:

# Instead of the old synchronous call, use this:
if st.button("üîÑ Generate Documents", key="generate_direct_documents", type="primary"):
    from async_direct_changes import start_direct_changes_background
    
    # Start background processing
    analysis_id = start_direct_changes_background(
        uploaded_file.getvalue(),
        uploaded_file.name,
        selected_findings,
        user_comments
    )
    st.rerun()
# Show processing status
if st.session_state.direct_processing_status == 'processing':
    st.info(f"üîÑ {st.session_state.direct_processing_message}")
    progress_bar = st.progress(st.session_state.direct_processing_progress / 100)
    
    # Auto-refresh every 2 seconds
    time.sleep(0.5)
    st.rerun()
elif st.session_state.direct_processing_status == 'completed':
    st.success("‚úÖ Documents generated successfully!")
    
    results = st.session_state.direct_processing_results
    if results:
        original_name = results['original_filename'].replace('.docx', '')
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.download_button(
                label="üìÑ Download Tracked Changes Document",
                data=results['tracked_changes_content'],
                file_name=f"{original_name}_tracked_changes.docx",
                mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document"
            )
        
        with col2:
            st.download_button(
                label="üìÑ Download Clean Edited Document", 
                data=results['clean_edited_content'],
                file_name=f"{original_name}_clean_edited.docx",
                mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document"
            )
elif st.session_state.direct_processing_status == 'error':
    st.error(f"‚ùå Error: {st.session_state.direct_processing_error}")
    if st.button("üîÑ Try Again", key="reset_direct_error"):
        st.session_state.direct_processing_status = 'idle'
        st.rerun()
These are the only changes needed for async functionality. You can rollback to your original app and just add these specific pieces to get the async Direct Tracked Changes working without changing the overall app structure.